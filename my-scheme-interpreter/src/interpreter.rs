use crate::env;
use crate::eval_tco::eval_forms;
use crate::heap::Heap;
use crate::reader::StringReader;
use crate::scheme_libs::std::SCM_LIB_STD;
use crate::scm_types::scm_val::Pointer;
use crate::utils;

// TODO test some errors in here for eval_string.
//
// TODO other libraries need to be loadable with require or something. Since some
// are supposed to be built in, but not loaded at startup, there will have to
// be a builtin called Builtin::Require or something and it will have to explicitly
// import the rust file, read it, and eval it with the current env and heap.
// like define this will only be callable at the top level I guess.

pub struct Interpreter {
    env: Pointer,
    heap: Heap,
    ready: bool,
}

impl Interpreter {
    // Create a new interpreter with an empty environment
    pub fn new() -> Interpreter {
        let mut heap = Heap::new();
        Interpreter {
            env: env::new(vec![], &mut heap),
            heap: heap,
            ready: false,
        }
    }

    // Initialize the interpreter.
    // Loads the base environment and the standard library.
    pub fn init(mut self) -> Interpreter {
        self.ready = true;
        self.env = self.setup_env();
        self
    }

    pub fn eval_string(&mut self, text: &str) -> String {
        if !self.ready {
            panic!("not initialized");
        }

        let result = match StringReader::new(text, &mut self.heap).read_forms() {
            Ok(forms) => eval_forms(forms, self.env, &mut self.heap),
            Err(e) => panic!("{e}"),
        };

        match result {
            Ok(val) => utils::val_to_string(val, &self.heap),
            Err(e) => format!("{e}"),
        }
    }

    // create a new environment and add the values to it.
    // uses env, builtins, and an autogenerated file with librairy defines
    fn setup_env(&mut self) -> Pointer {
        let base_env = env::new_base_env(&mut self.heap);

        // Eval scheme standard lib
        let lib_std_str = match StringReader::new(SCM_LIB_STD, &mut self.heap).read_forms() {
            Ok(s) => s,
            Err(e) => panic!("failed to read SCM_LIB_STD: Err: {e}"),
        };
        match eval_forms(lib_std_str, base_env, &mut self.heap) {
            Err(e) => panic!("failed to eval SCM_LIB_STD: Err: {e}"),
            _ => (),
        };

        // Return the env. If all libs use define their values and functions will
        // be added to the environment without adding a new scope, so the base_env
        // pointer will still be valid
        base_env
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_evaluating_simple_forms_with_definitions() {
        let mut int = Interpreter::new().init();

        // Basic forms
        assert_eq!(int.eval_string(""), "()".to_string());
        assert_eq!(int.eval_string("1"), "1".to_string());

        // Define and use
        assert_eq!(int.eval_string("(define a 5)"), "()".to_string());
        assert_eq!(int.eval_string("a"), "5".to_string());
        assert_eq!(int.eval_string("'a"), "a".to_string());
        assert_eq!(int.eval_string("(+ a 10)"), "15".to_string());

        // Define and call a lambda
        assert_eq!(
            int.eval_string("(define f (lambda (x) (+ x 1)))"),
            "()".to_string()
        );
        assert_eq!(int.eval_string("(f a)"), "6".to_string());

        // Redefine a
        assert_eq!(int.eval_string("(define a 33)"), "()".to_string());
        assert_eq!(int.eval_string("a"), "33".to_string());

        // Multiple forms at once
        assert_eq!(
            int.eval_string("(define b 6)\n\n(+ b a)\n\n(- a b)\n"),
            "27".to_string()
        );

        // Check that the stdlib was infact loaded. MIGHT BREAK LATER.
        assert_eq!(int.eval_string("(equal? a 33)"), "#t".to_string());
    }
}
